$ErrorActionPreference = "SilentlyContinue"

# Funzione per ottenere la firma del file
function Get-Signature {
    [CmdletBinding()]
    param (
        [string[]]$FilePath
    )

    $Existence = Test-Path -PathType "Leaf" -Path $FilePath
    $Authenticode = (Get-AuthenticodeSignature -FilePath $FilePath -ErrorAction SilentlyContinue).Status
    $Signature = "Invalid Signature (UnknownError)"

    if ($Existence) {
        if ($Authenticode -eq "Valid") {
            $Signature = "Valid Signature"
        }
        elseif ($Authenticode -eq "NotSigned") {
            $Signature = "Invalid Signature (NotSigned)"
        }
        elseif ($Authenticode -eq "HashMismatch") {
            $Signature = "Invalid Signature (HashMismatch)"
        }
        elseif ($Authenticode -eq "NotTrusted") {
            $Signature = "Invalid Signature (NotTrusted)"
        }
        elseif ($Authenticode -eq "UnknownError") {
            $Signature = "Invalid Signature (UnknownError)"
        }
        return $Signature
    } else {
        $Signature = "File Was Not Found"
        return $Signature
    }
}

# Funzione per determinare su quale disco si trova il file
function Get-DriveInfo {
    param (
        [string]$FilePath
    )
    $driveLetter = $FilePath.Split(":")[0]
    $drive = Get-PSDrive -Name $driveLetter

    if ($drive) {
        return $drive.FileSystem
    } else {
        return "Drive Not Found"
    }
}

# Funzione per controllare se il file è stato eliminato o spostato nel cestino
function Check-FileDeletion {
    param (
        [string]$FilePath
    )

    if (Test-Path -Path $FilePath) {
        return "File Exists"
    }

    $recycleBinPath = "$env:SystemDrive\$Recycle.Bin"
    $recycleItems = Get-ChildItem -Recurse -Force $recycleBinPath | Where-Object { $_.PSIsContainer -eq $false } | Select-Object FullName
    $foundInRecycle = $recycleItems | Where-Object { $_.FullName -like "*$FilePath*" }

    if ($foundInRecycle) {
        return "File Moved to Recycle Bin"
    } else {
        return "File Deleted Permanently"
    }
}

# Funzione per controllare se la chiave UserSettings esiste
function Check-UserSettingsKey {
    param (
        [string]$Sid
    )

    $userSettingsPath = "HKLM:\SYSTEM\CurrentControlSet\Services\bam\state\UserSettings\$Sid"

    if (-not (Test-Path $userSettingsPath)) {
        if ($Sid -like "S-1-5-90*") {
            return "SID di sistema - Non necessario controllare"
        } else {
            return "L'utente a cui stai facendo il controllo sta cercando di bypassarti perché la Key di regedit UserSettings non esiste."
        }
    } else {
        return "Chiave UserSettings trovata."
    }
}

# Funzione per avviare il BAM con tutte le funzionalità richieste
function Start-Bam {
    $sw = [Diagnostics.Stopwatch]::StartNew()

    if (!(Get-PSDrive -Name HKLM -PSProvider Registry)) {
        Try {
            New-PSDrive -Name HKLM -PSProvider Registry -Root HKEY_LOCAL_MACHINE
        }
        Catch {
            Write-Warning "Error Mounting HKEY_Local_Machine"
        }
    }

    $bv = ("bam", "bam\State")
    Try {
        $Users = foreach($ii in $bv) {
            Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\$($ii)\UserSettings\" | Select-Object -ExpandProperty PSChildName
        }
    }
    Catch {
        Write-Warning "Error Parsing BAM Key. Likely unsupported Windows Version"
        Exit
    }

    $rpath = @("HKLM:\SYSTEM\CurrentControlSet\Services\bam\","HKLM:\SYSTEM\CurrentControlSet\Services\bam\state\")

    $Bam = foreach ($Sid in $Users) {
        $keyCheck = Check-UserSettingsKey -Sid $Sid
        if ($keyCheck -notlike "Chiave UserSettings trovata.") {
            Write-Host $keyCheck
            continue
        }

        foreach($rp in $rpath) {
            $BamItems = Get-Item -Path "$($rp)UserSettings\$Sid" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Property
            foreach ($Item in $BamItems) {
                $Hex = [System.BitConverter]::ToString($Item[7..0]) -replace "-",""
                $TimeLocal = Get-Date ([DateTime]::FromFileTime([Convert]::ToInt64($Hex, 16))) -Format "yyyy-MM-dd HH:mm:ss"
                $driveInfo = Get-DriveInfo -FilePath $Item

                [PSCustomObject]@{
                    'Examiner Time' = $TimeLocal
                    Application = $Item
                    Drive = $driveInfo
                }
            }
        }
    }

    $Bam | Out-GridView -PassThru -Title "BAM key entries"
    $sw.Stop()
    $t = $sw.Elapsed.TotalMinutes
    Write-Host "Elapsed Time $t Minutes" -ForegroundColor Yellow
}

# Avvia il BAM
Start-Bam

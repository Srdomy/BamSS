$ErrorActionPreference = "SilentlyContinue"

# Funzione per ottenere la firma del file
function Get-Signature {
    param (
        [string[]]$FilePath
    )
    $Existence = Test-Path -PathType "Leaf" -Path $FilePath
    $Authenticode = (Get-AuthenticodeSignature -FilePath $FilePath -ErrorAction SilentlyContinue).Status
    $Signature = "Invalid Signature (UnknownError)"

    if ($Existence) {
        switch ($Authenticode) {
            "Valid" { $Signature = "Valid Signature" }
            "NotSigned" { $Signature = "Invalid Signature (NotSigned)" }
            "HashMismatch" { $Signature = "Invalid Signature (HashMismatch)" }
            "NotTrusted" { $Signature = "Invalid Signature (NotTrusted)" }
            "UnknownError" { $Signature = "Invalid Signature (UnknownError)" }
        }
        return $Signature
    } else {
        return "File Was Not Found"
    }
}

# Funzione per determinare su quale disco si trova il file e il tipo di file system
function Get-DriveInfo {
    param (
        [string]$FilePath
    )
    $driveLetter = $FilePath.Split(":")[0]
    $drive = Get-PSDrive -Name $driveLetter
    return @{
        Drive = $driveLetter
        FileSystem = $drive.Provider.Name
    }
}

# Funzione per controllare se il file è stato eliminato o spostato nel cestino
function Check-FileDeletion {
    param (
        [string]$FilePath
    )
    if (Test-Path -Path $FilePath) {
        return "File Exists"
    }

    $recycleBinPath = "$env:SystemDrive\$Recycle.Bin"
    $recycleItems = Get-ChildItem -Recurse -Force $recycleBinPath | Where-Object { $_.PSIsContainer -eq $false } | Select-Object FullName
    $foundInRecycle = $recycleItems | Where-Object { $_.FullName -like "*$FilePath*" }

    if ($foundInRecycle) {
        return "File Moved to Recycle Bin"
    } else {
        return "File Deleted Permanently (Shift+Del or Cleared from Recycle Bin)"
    }
}

Clear-Host

# Interfaccia grafica di avvio
Write-Host "" -ForegroundColor Red
Write-Host "░▒▓███████▓▒░▒▓████████▓▒░▒▓█▓▒░      ░▒▓████████▓▒░      ░▒▓███████▓▒░ ░▒▓██████▓▒░░▒▓██████████████▓▒░       ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ " -ForegroundColor Red
Write-Host "░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░             ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓████▓▒░ " -ForegroundColor Red
Write-Host "░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░             ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░       ░▒▓█▓▒▒▓█▓▒░   ░▒▓█▓▒░ " -ForegroundColor Red
Write-Host " ░▒▓██████▓▒░░▒▓██████▓▒░ ░▒▓█▓▒░      ░▒▓██████▓▒░        ░▒▓███████▓▒░░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░       ░▒▓█▓▒▒▓█▓▒░   ░▒▓█▓▒░ " -ForegroundColor Red
Write-Host "       ░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░             ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░        ░▒▓█▓▓█▓▒░    ░▒▓█▓▒░ " -ForegroundColor Red
Write-Host "       ░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░             ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░        ░▒▓█▓▓█▓▒░    ░▒▓█▓▒░ " -ForegroundColor Red
Write-Host "░▒▓███████▓▒░░▒▓████████▓▒░▒▓████████▓▒░▒▓█▓▒░             ░▒▓███████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░         ░▒▓██▓▒░     ░▒▓█▓▒░ " -ForegroundColor Red
Write-Host "                                                                                                                                        " -ForegroundColor Red
Write-Host "  *Made by Srdomy*" -ForegroundColor Gray -NoNewline
Write-Host "" -ForegroundColor Gray

# Funzione per controllare se si dispone dei privilegi di amministratore
function Test-Admin {
    $currentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())
    return $currentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
}
if (!(Test-Admin)) {
    Write-Warning "Please Run This Script as Admin."
    Start-Sleep 10
    Exit
}

Write-Host "Checking for registry access..." -ForegroundColor Yellow

if (!(Get-PSDrive -Name HKLM -PSProvider Registry)) {
    Try {
        New-PSDrive -Name HKLM -PSProvider Registry -Root HKEY_LOCAL_MACHINE
    } Catch {
        Write-Warning "Error Mounting HKEY_Local_Machine"
        Exit
    }
}

Write-Host "Registry access verified." -ForegroundColor Green

# Ottieni utenti BAM
$bv = ("bam", "bam\State")
Try {
    $Users = foreach($ii in $bv) {
        Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\$($ii)\UserSettings\" | Select-Object -ExpandProperty PSChildName
    }
} Catch {
    Write-Warning "Error Parsing BAM Key. Likely unsupported Windows Version"
    Exit
}

Write-Host "BAM users retrieved: $($Users.Count)" -ForegroundColor Green

$rpath = @("HKLM:\SYSTEM\CurrentControlSet\Services\bam\","HKLM:\SYSTEM\CurrentControlSet\Services\bam\state\")

# Getting TimeZone Information
$UserTime = (Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\TimeZoneInformation").TimeZoneKeyName
$UserBias = (Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\TimeZoneInformation").ActiveTimeBias
$UserDay = (Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\TimeZoneInformation").DaylightBias

# Fetch BAM items
$Bam = foreach ($Sid in $Users) {
    foreach($rp in $rpath) {
        $BamItems = Get-Item -Path "$($rp)UserSettings\$Sid" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Property
        
        Try {
            $objSID = New-Object System.Security.Principal.SecurityIdentifier($Sid)
            $User = $objSID.Translate([System.Security.Principal.NTAccount]) 
            $User = $User.Value
        } Catch {
            $User = ""
        }
        
        foreach ($Item in $BamItems) {
            $Key = Get-ItemProperty -Path "$($rp)UserSettings\$Sid" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty $Item

            if ($key.length -eq 24) {
                $Hex = [System.BitConverter]::ToString($key[7..0]) -replace "-",""
                $TimeLocal = Get-Date ([DateTime]::FromFileTime([Convert]::ToInt64($Hex, 16))) -Format "yyyy-MM-dd HH:mm:ss"
                $TimeUTC = Get-Date -Date $TimeLocal -Format "yyyy-MM-dd HH:mm:ss" -uformat "%Y-%m-%d %H:%M:%S" -AsUTC
                $Biasd = $UserBias
                $Dayd = $UserDay
                $path = [System.Text.Encoding]::UTF8.GetString($key[15..12]) -replace [char]0, ""
                $d = $path.Substring(0,1)

                if (Test-Path -Path "$($d):\$($f)") {
                    $driveInfo = Get-DriveInfo -FilePath $path
                    $Sig = Get-Signature -FilePath $path
                    $deletionStatus = Check-FileDeletion -FilePath $path
                    
                    # Creazione oggetto BAM
                    [PSCustomObject]@{
                        'Time UTC' = $TimeUTC
                        'Time Local' = $TimeLocal
                        'User Time' = $TimeUser
                        'Bias' = $Biasd
                        'Daylight Bias' = $Dayd
                        Path = $path
                        Signature = $Sig
                        Drive = $driveInfo.Drive
                        FileSystem = $driveInfo.FileSystem
                        'Deletion Status' = $deletionStatus
                        User = $User
                        SID = $Sid
                        Regpath = $rp
                    }
                }
            }
        }
    }
}

# Funzione per cercare chiavi recenti
function Get-RecentKeys {
    $recentKeysPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*"
    $recentKeys = Get-ItemProperty -Path $recentKeysPath | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate
    return $recentKeys
}

$RecentKeys = Get-RecentKeys

# Mostra il contenuto di BAM e le chiavi recenti
$Bam | Out-GridView -PassThru -Title "BAM key entries $($Bam.count) - User TimeZone: ($UserTime) -> ActiveBias: ($Bias) - DayLightTime: ($Day)"
$RecentKeys | Out-GridView -PassThru -Title "Recent Installed Applications"

Write-Host ""
$t = (Get-Date) - $start
Write-Host "Elapsed Time $([math]::round($t.TotalMinutes, 2)) Minutes" -ForegroundColor Yellow

$ErrorActionPreference = "SilentlyContinue"

# Funzione per ottenere la firma del file
function Get-Signature {
    param (
        [string]$FilePath
    )

    if (Test-Path -PathType "Leaf" -Path $FilePath) {
        $authStatus = (Get-AuthenticodeSignature -FilePath $FilePath -ErrorAction SilentlyContinue).Status
        switch ($authStatus) {
            "Valid" { return "Valid Signature" }
            "NotSigned" { return "Invalid Signature (NotSigned)" }
            "HashMismatch" { return "Invalid Signature (HashMismatch)" }
            "NotTrusted" { return "Invalid Signature (NotTrusted)" }
            default { return "Invalid Signature (UnknownError)" }
        }
    } else {
        return "File Was Not Found"
    }
}

# Funzione per determinare il tipo di file system dell'hard disk
function Get-FileSystemType {
    param (
        [string]$DriveLetter
    )

    $driveInfo = Get-WmiObject -Class Win32_LogicalDisk | Where-Object { $_.DeviceID -eq $DriveLetter }
    if ($driveInfo) {
        return $driveInfo.FileSystem
    } else {
        return "FileSystem Not Found"
    }
}

# Funzione per controllare se l'hard disk esiste ancora
function Check-DriveExists {
    param (
        [string]$DriveLetter
    )

    if (Test-Path $DriveLetter) {
        return "Drive Exists"
    } else {
        return "Drive Not Found"
    }
}

# Funzione per controllare se il file è stato eliminato o spostato nel cestino
function Check-FileDeletion {
    param (
        [string]$FilePath
    )

    if (Test-Path -Path $FilePath) {
        return "File Exists"
    }

    # Controlla il Cestino
    try {
        $recycleBinPath = "$env:SystemDrive\$Recycle.Bin"
        $recycleItems = Get-ChildItem -Path $recycleBinPath -Recurse -Force -ErrorAction SilentlyContinue | Where-Object { -not $_.PSIsContainer } | Select-Object -ExpandProperty FullName
        $foundInRecycle = $recycleItems -like "*$FilePath*"
        if ($foundInRecycle) {
            return "File Moved to Recycle Bin"
        } else {
            return "File Deleted Permanently (Shift+Del or Cleared from Recycle Bin)"
        }
    } catch {
        return "Error Checking Recycle Bin"
    }
}

# Funzione per verificare e avviare il servizio BAM
function Ensure-BAMService {
    $service = Get-Service -Name bam -ErrorAction SilentlyContinue
    if ($service) {
        if ($service.Status -ne 'Running') {
            Write-Host "Starting BAM service..." -ForegroundColor Green
            try {
                Start-Service -Name bam -ErrorAction Stop
                Write-Host "BAM service started." -ForegroundColor Green
            }
            catch {
                Write-Warning "Failed to start BAM service: $_"
            }
        }
        else {
            Write-Host "BAM service is already running." -ForegroundColor Green
        }
    }
    else {
        Write-Warning "BAM service not found."
    }
}

# Pulizia della console
Clear-Host

# Logo migliorato
$logo = @"
██████╗░██╗░░░██╗███╗░░░███╗██████╗░
██╔══██╗██║░░░██║████╗░████║██╔══██╗
██║░░██║██║░░░██║██╔████╔██║██████╦╝
██║░░██║██║░░░██║██║╚██╔╝██║██╔══██╗
██████╔╝╚██████╔╝██║░╚═╝░██║██████╦╝
╚═════╝░░╚═════╝░╚═╝░░░░░╚═╝╚═════╝░

░██████╗░██████╗
██╔════╝██╔════╝
╚█████╗░╚█████╗░
░╚═══██╗░╚═══██╗
██████╔╝██████╔╝
╚═════╝░╚═════╝░

██████╗░░█████╗░███╗░░░███╗
██╔══██╗██╔══██╗████╗░████║
██████╦╝███████║██╔████╔██║
██╔══██╗██╔══██║██║╚██╔╝██║
██████╦╝██║░░██║██║░╚═╝░██║
╚═════╝░╚═╝░░╚═╝╚═╝░░░░░╚═╝

Made by Srdomy
"@

Write-Host $logo -ForegroundColor Red
Write-Host ""

# Funzione per controllare se si dispone dei privilegi di amministratore
function Test-Admin {
    $currentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())
    return $currentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
}

if (!(Test-Admin)) {
    Write-Warning "Please Run This Script as Admin."
    Start-Sleep 10
    Exit
}

# Avvia il timer
$sw = [Diagnostics.Stopwatch]::StartNew()

# Assicurarsi che il drive HKLM sia montato
if (!(Get-PSDrive -Name HKLM -PSProvider Registry -ErrorAction SilentlyContinue)) {
    Try {
        New-PSDrive -Name HKLM -PSProvider Registry -Root HKEY_LOCAL_MACHINE -ErrorAction Stop
    }
    Catch {
        Write-Warning "Error Mounting HKEY_LOCAL_MACHINE: $($_)"
        Exit
    }
}

# Percorsi del registro BAM
$bamPaths = @("HKLM:\SYSTEM\CurrentControlSet\Services\bam\UserSettings\", "HKLM:\SYSTEM\CurrentControlSet\Services\bam\state\UserSettings\")

# Raccogliere gli SID degli utenti
$Users = @()
foreach ($path in $bamPaths) {
    Try {
        $currentUsers = Get-ChildItem -Path $path -ErrorAction Stop | Select-Object -ExpandProperty PSChildName
        $Users += $currentUsers
    }
    Catch {
        Write-Warning "Error accessing path $path: $($_)"
    }
}

# Rimuovere duplicati
$Users = $Users | Select-Object -Unique

# Informazioni sul fuso orario
$timeZoneInfo = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\TimeZoneInformation"
$UserTimeZone = $timeZoneInfo.TimeZoneKeyName
$UserBias = $timeZoneInfo.ActiveTimeBias
$UserDaylightBias = $timeZoneInfo.DaylightBias

# Inizializzare l'array dei risultati
$results = @()

# Elaborare ogni SID
foreach ($Sid in $Users) {
    foreach ($rp in $bamPaths) {
        $userSettingsPath = "$rp$Sid"
        Try {
            $properties = Get-ItemProperty -Path $userSettingsPath -ErrorAction Stop | Get-Member -MemberType NoteProperty | Select-Object -ExpandProperty Name
        }
        Catch {
            Write-Warning "Error accessing $userSettingsPath: $($_)"
            continue
        }

        # Tradurre SID in nome utente
        Try {
            $objSID = New-Object System.Security.Principal.SecurityIdentifier($Sid)
            $User = $objSID.Translate([System.Security.Principal.NTAccount]).Value
        }
        Catch {
            $User = "Unknown"
        }

        foreach ($Item in $properties) {
            Try {
                $KeyValue = (Get-ItemProperty -Path $userSettingsPath -Name $Item -ErrorAction Stop).$Item
            }
            Catch {
                Write-Warning "Error getting property $Item from $userSettingsPath: $($_)"
                continue
            }

            if ($KeyValue.Length -eq 24) {
                # Estrarre il timestamp dal valore della chiave
                try {
                    $Hex = [System.BitConverter]::ToString($KeyValue[7..0]) -replace "-", ""
                    $FileTime = [Convert]::ToInt64($Hex, 16)
                    $TimeLocal = [DateTime]::FromFileTime($FileTime).ToString("yyyy-MM-dd HH:mm:ss")
                    $TimeUTC = [DateTime]::FromFileTimeUtc($FileTime).ToString("yyyy-MM-dd HH:mm:ss")
                    $TimeUser = [DateTime]::FromFileTimeUtc($FileTime).AddMinutes($UserBias).ToString("yyyy-MM-dd HH:mm:ss")
                    
                    # Processare $Item come percorso file, se possibile
                    # Supponiamo che $Item contenga un percorso file in formato \Device\HarddiskVolumeX\path\file.exe
                    $path = ""
                    if ($Item -match "^\\Device\\HarddiskVolume([0-9]+)\\(.+)$") {
                        $volNum = $matches[1]
                        $relativePath = $matches[2]
                        $driveLetter = (Get-WmiObject -Query "SELECT * FROM Win32_LogicalDisk WHERE VolumeName LIKE 'HarddiskVolume$volNum%'").DeviceID
                        if ($driveLetter) {
                            $path = "$driveLetter\$relativePath"
                        }
                    }

                    # Inserire i dati nell'array dei risultati
                    $results += [pscustomobject]@{
                        User = $User
                        SID = $Sid
                        Path = $Item
                        TimeUTC = $TimeUTC
                        TimeLocal = $TimeLocal
                        TimeUser = $TimeUser
                    }
                }
                catch {
                    Write-Warning "Error processing $Item: $($_)"
                }
            }
        }
    }
}

# Arrestare il timer
$sw.Stop()

# Mostrare i risultati
$results | Format-Table -AutoSize

Write-Host "Completed in $($sw.Elapsed.TotalSeconds) seconds." -ForegroundColor Green
